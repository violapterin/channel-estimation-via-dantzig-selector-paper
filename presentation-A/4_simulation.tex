\Frame {Real Valued Representation}
{
\I To solve the convex optimization, we use Python package CVXPY.

\I Since it doesn't allow complex variables, we represent complex number by real part and imarinary parts.

\I For vectors, substitute
\Disp {
\NC a +b \Ss{i}
\leftrightarrow \NC \startTheMatrix
\NC a \NR
\NC b \NR
\stopTheMatrix \NR
}

\I For matrices, substitute
\Disp {
\NC a +b \Ss{i}
\leftrightarrow \NC \startTheMatrix
\NC a, \NC -b \NR
\NC b, \NC a \NR
\stopTheMatrix \NR
}
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Algorithm Cast as SOCP (1/3)}
{
\I Given are \m{\M {P} \in \MB {C} ^{N_Y^2 \D N_H^2}}, \m {\V {y} \in \MB {C} ^{N_Y^2}}, \m{\g > 0}.
Let \m {\T {\V {y}}} be the real representation of \m {\V {y}}, and \m {\T {\M {P}}} that of \m {\M {P}}.

\I Define the indicator vectors and matrices as
\Disp {
\NC {\V {u}}_{n_h} \SB {n_h'}
= \NC \startcases
1, \Q \MC n_h' =n_h \NR
0, \Q \NC \Rm {otherwise} \NR
\stopcases \NR
%
\NC {\T {\M {U}}}_{n_h} \SB {n_h', n_h''}
= \NC \startcases
1, \Q \MC n_h' =2n_h,\; n_h'' =2n_h \NR
1, \Q \MC n_h' =2n_h +1,\; n_h'' =2n_h +1 \NR
0, \Q \NC \Rm {otherwise} \NR
\stopcases \NR
}
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Algorithm Cast as SOCP (2/3)}
{
\I A moment of reflection shows that, to fit the form of SOCP, we just have to define \m {\V {t}, \M {A}_i, \V {b}_i, \V {c}_i, d_i}, for \m {i = 0, 1, \ldots, N_H^2 -1},
\Disp{
\NC \V {t}
= \NC \startTheMatrix
\NC \V {0} \NR
\NC \V {1} \NR
\stopTheMatrix,
\quad \M {A}_i
= \startTheMatrix
\NC \T {\M {U}}_{i}, \NC \M {0} \NR
\stopTheMatrix \NR
%
\NC \V {b}_i
=\NC \V {0},
\quad \V {c}_i
= \startTheMatrix
\NC \V {0} \NR
\NC \V {u}_{i} \NR
\stopTheMatrix,
\quad d_i
= 0 \NR
}

\I Similarly, for \m {i = N_H^2, N_H^2 +1, \ldots, 2N_H^2 -1},
\Disp{
\NC \M {A}_i
= \NC \startTheMatrix
\NC -\T {\M {U}}_{i -N_H^2} \T {\M {P}}^\Adj \T {\M {P}}, \NC \M {0} \NR
\stopTheMatrix, \NR
%
\NC \V {b}_i
=\NC \T {\M {U}}_{i -N_H^2} \T {\M {P}}^\Adj \T {\V {y}},
\quad \V {c}_i
= \V {0},
\quad d_i
= \g \NR
}
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Algorithm Cast as SOCP (3/3)}
{
\I Now, run the Second Order Cone Programming:
\Disp{
\NC \Hat {\V {x}}
\LA \NC \startcases
\NC \Min {\V {x}'}
\MC \IP {\V {t}, \V {x}'} \NR
\NC \Rm {subject} \; \Rm {to}
\Q  \MC \VNm {\M {A} _{i} \V {x}' +\V {b} _{i}} _2
\leq \IP {\V {c}_{i}, \V {x}'} +\V {d}_i \NR
\NC \MC i 
=0, 1, \ldots, 2N_H^2 -1 \NR
\stopcases \NR
}
\I Extract channel response as real vector:
\Disp {
\NC \Hat{\V {g}}
\LA \NC \MC{R} ^{-1} \SB {\Hat{\V {x}} \DB {0 : 2N_H^2-1}} \NR
}
\I Convert back from Angular domain and output:
\Disp {
\NC \Hat {\M {H}}
\LA \NC \M {K} \Rm {vec}^{-1} \SB {\Hat {g}} \M {K}^\Adj \NR
}
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Performance Metric}
{
\I Log theoretical expected error:
\Disp {
\NC \eta_{\Ss{th}}
=\NC \F{5}{2} + \log \RB{L N_H} + \log \log N_H \NR
}

\I Log absolute error:
\Disp {
\NC \eta_{\Ss{abs}}
=\NC \RB {\log_2 {\VNm {\V {h} -\Hat {\V {h}}}_2}} _{\Ss{avg}} \NR
}

\I Relative error:
\Disp {
\NC \eta_{\Ss{rel}}
=\NC \F {\RB {\log_2 {\VNm {\V {h} -\Hat {\V {h}}}_2}} _{\Ss{avg}}}
{\RB {\log_2 {\VNm {\V {h}}_2}} _{\Ss{avg}}} \NR
}
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Simulation Parameters}
{
\I Antennae number of digital stage \m {N_Y = 4}
\I Antennae number of analog stage \m {N_R = 8}
\I Antennae number of channel \m {N_H = 12}
\I Analog beamformer quantization grid: 16
\I Number of paths \m {L =4}
\I Number of noise std.\ values tried: 12
\I Number of \m {\g} values tried: 4
\I Number of repetition of each data point: 18
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Absolute Error (Less Data Points)}
{
\blank [big]
\externalfigure [sim_1_abs.png] [factor=broad]
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Relative Error (Less Data Points)}
{
\blank [big]
\externalfigure [sim_1_rel.png] [factor=broad]
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Simulation Parameters}
{
\I Antennae number of digital stage \m {N_Y = 8}
\I Antennae number of analog stage \m {N_R = 12}
\I Antennae number of channel \m {N_H = 16}
\I Analog beamformer quantization grid: 16
\I Number of paths \m {L =4}
\I Number of noise std.\ values tried: 12
\I Number of \m {\g} values tried: 4
\I Number of repetition of each data point: 18
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Absolute Error (More Data Points)}
{
\blank [big]
\externalfigure [sim_2_abs.png] [factor=broad]
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Relative Error (More Data Points)}
{
\blank [big]
\externalfigure [sim_2_rel.png] [factor=broad]
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Discussion}
{

\I \m {\eta_{\Ss{th}}} is in correct order of magnitude, but \m {\eta_{\Ss{abs}} \ll \eta_{\Ss{th}}}, i.e., the bound is not tight.

\I The smaller \m {\g}, the smaller \m {\eta_{\Ss{abs}}}.

\I The smaller the noise std., the smaller \m {\eta_{\Ss{abs}}}.

\I The lines are bumpy, and we have to do more experiments to smooth them out.

\I Many of the experiments are pretty accurate, but those that has small \m {\VNm {\V {h}} _2} contribute significantly to a bigger \m {\eta_{\Ss{rel}}}.
}
% % % % % % % % % % % % % % % % % % % % % % % % % %

