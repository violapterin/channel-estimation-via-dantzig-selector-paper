\Frame {Real Valued Representation}
{
\I To solve the convex optimization, we use Python package CVXPY.

\I Since it doesn't allow complex variables, we represent complex number by real part and imarinary parts.

\I For vectors, substitute
\Disp {
\NC a +b \Ss{i}
\leftrightarrow \NC \startTheMatrix
\NC a \NR
\NC b \NR
\stopTheMatrix \NR
}

\I For matrices, substitute
\Disp {
\NC a +b \Ss{i}
\leftrightarrow \NC \startTheMatrix
\NC a, \NC -b \NR
\NC b, \NC a \NR
\stopTheMatrix \NR
}
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Algorithm Cast as SOCP (1/3)}
{
\I Given are \m{\M {P} \in \MB {C} ^{N_Y^2 \D N_H^2}}, \m {\V {y} \in \MB {C} ^{N_Y^2}}, \m{\g > 0}.
Let \m {\T {\V {y}}} be the real representation of \m {\V {y}}, and \m {\T {\M {P}}} that of \m {\M {P}}.

\I Define the indicator vectors and matrices as
\Disp {
\NC {\V {u}}_{n_h} \DB {n_h'}
= \NC \startcases
1, \Q \MC n_h' =n_h \NR
0, \Q \NC \Rm {otherwise} \NR
\stopcases \NR
%
\NC {\T {\M {U}}}_{n_h} \DB {n_h', n_h''}
= \NC \startcases
1, \Q \MC n_h' =2n_h,\; n_h'' =2n_h \NR
1, \Q \MC n_h' =2n_h +1,\; n_h'' =2n_h +1 \NR
0, \Q \NC \Rm {otherwise} \NR
\stopcases \NR
}
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Algorithm Cast as SOCP (2/3)}
{
\I A moment of reflection shows that, to fit the form of SOCP, we just have to define \m {\V {t}, \M {A}_i, \V {b}_i, \V {c}_i, d_i}, for \m {i = 0, 1, \ldots, N_H^2 -1},
\Disp{
\NC \V {t}
= \NC \startTheMatrix
\NC \V {0} \NR
\NC \V {1} \NR
\stopTheMatrix,
\quad \M {A}_i
= \startTheMatrix
\NC \T {\M {U}}_{i}, \NC \M {0} \NR
\stopTheMatrix \NR
%
\NC \V {b}_i
=\NC \V {0},
\quad \V {c}_i
= \startTheMatrix
\NC \V {0} \NR
\NC \V {u}_{i} \NR
\stopTheMatrix,
\quad d_i
= 0 \NR
}

\I Similarly, for \m {i = N_H^2, N_H^2 +1, \ldots, 2N_H^2 -1},
\Disp{
\NC \M {A}_i
= \NC \startTheMatrix
\NC -\T {\M {U}}_{i -N_H^2} \T {\M {P}}^\Adj \T {\M {P}}, \NC \M {0} \NR
\stopTheMatrix, \NR
%
\NC \V {b}_i
=\NC \T {\M {U}}_{i -N_H^2} \T {\M {P}}^\Adj \T {\V {y}},
\quad \V {c}_i
= \V {0},
\quad d_i
= \g \NR
}
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Algorithm Cast as SOCP (3/3)}
{
\I Now, run the Second Order Cone Programming:
\Disp{
\NC \Hat {\V {x}}
\LA \NC \startcases
\NC \Min {\V {x}'}
\MC \IP {\V {t}, \V {x}'} \NR
\NC \Rm {subject} \; \Rm {to}
\Q  \MC \VNm {\M {A} _{i} \V {x}' +\V {b} _{i}} _2
\leq \IP {\V {c}_{i}, \V {x}'} +\V {d}_i \NR
\NC \MC i 
=0, 1, \ldots, 2N_H^2 -1 \NR
\stopcases \NR
}
\I Extract channel response as real vector:
\Disp {
\NC \Hat{\V {g}}
\LA \NC \MC{R} ^{-1} \SB {\Hat{\V {x}} \DB {0 : 2N_H^2-1}} \NR
}
\I Convert back from Angular domain and output:
\Disp {
\NC \Hat {\M {H}}
\LA \NC \M {K} \Rm {vec}^{-1} \SB {\Hat {g}} \M {K}^\Adj \NR
}
}

% % % % % % % % % % % % % % % % % % % % % % % % % %

\Frame {Simulation Parameters}
{
\I Antenae number of digital stage \m {N_Y = 4}
\I Antenae number of analog stage \m {N_R = 8}
\I Antenae number of channel \m {N_H = 12}
\I Analog beamformer quantization grid: 16
\I Number of paths \m {L =4}
\I Number of noise std.\ values tried: 12
\I Number of \m {\g} values tried: 4
\I Number of repetition of each data point: 18
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Performance Metric}
{
\I Log theoretical expected error:
\Disp {
\NC \eta_{\Ss{th}}
=\NC \F{5}{2} + \log \RB{L N_H} + \log \log N_H \NR
}

\I Log absolute error:
\Disp {
\NC \eta_{\Ss{abs}}
=\NC \RB {\log_2 {\VNm {\V {h} -\Hat {\V {h}}}_2}} _{\Ss{avg}} \NR
}

\I Relative error:
\Disp {
\NC \eta_{\Ss{rel}}
=\NC \F {\RB {\log_2 {\VNm {\V {h} -\Hat {\V {h}}}_2}} _{\Ss{avg}}}
{\RB {\log_2 {\VNm {\V {h}}_2}} _{\Ss{avg}}} \NR
}
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Noise Std vs Absolute Error}
{
\blank [big]
\externalfigure [sim_1_abs.png] [factor=broad]
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Noise Std vs Relative Error}
{
\blank [big]
\externalfigure [sim_1_rel.png] [factor=broad]
}
% % % % % % % % % % % % % % % % % % % % % % % % % %
\Frame {Discussion}
{

\I \m {\eta_{\Ss{th}}} is in correct order of magnitude, but \m {\eta_{\Ss{abs}} \ll \eta_{\Ss{th}}}, i.e., the bound is not tight.

\I The smaller \m {\g}, the smaller \m {\eta_{\Ss{abs}}}.

\I The smaller the noise std., the smaller \m {\eta_{\Ss{abs}}}.

\I The lines are bumpy, and we have to do more experiments to smooth them out.

\I Many of the experiments are pretty accurate, but those that has small \m {\VNm {\V {h}} _2} contribute significantly to a bigger \m {\eta_{\Ss{rel}}}.
}
% % % % % % % % % % % % % % % % % % % % % % % % % %

